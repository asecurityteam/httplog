// Automatically generated by MockGen. DO NOT EDIT!
// Source: github.com/rs/xlog (interfaces: Logger,Output)

package stridelog

import (
	gomock "github.com/golang/mock/gomock"
	xlog "github.com/rs/xlog"
)

// Mock of Logger interface
type MockLogger struct {
	ctrl     *gomock.Controller
	recorder *_MockLoggerRecorder
}

// Recorder for MockLogger (not exported)
type _MockLoggerRecorder struct {
	mock *MockLogger
}

func NewMockLogger(ctrl *gomock.Controller) *MockLogger {
	mock := &MockLogger{ctrl: ctrl}
	mock.recorder = &_MockLoggerRecorder{mock}
	return mock
}

func (_m *MockLogger) EXPECT() *_MockLoggerRecorder {
	return _m.recorder
}

func (_m *MockLogger) Debug(_param0 ...interface{}) {
	_s := []interface{}{}
	for _, _x := range _param0 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "Debug", _s...)
}

func (_mr *_MockLoggerRecorder) Debug(arg0 ...interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Debug", arg0...)
}

func (_m *MockLogger) Debugf(_param0 string, _param1 ...interface{}) {
	_s := []interface{}{_param0}
	for _, _x := range _param1 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "Debugf", _s...)
}

func (_mr *_MockLoggerRecorder) Debugf(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	_s := append([]interface{}{arg0}, arg1...)
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Debugf", _s...)
}

func (_m *MockLogger) Error(_param0 ...interface{}) {
	_s := []interface{}{}
	for _, _x := range _param0 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "Error", _s...)
}

func (_mr *_MockLoggerRecorder) Error(arg0 ...interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Error", arg0...)
}

func (_m *MockLogger) Errorf(_param0 string, _param1 ...interface{}) {
	_s := []interface{}{_param0}
	for _, _x := range _param1 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "Errorf", _s...)
}

func (_mr *_MockLoggerRecorder) Errorf(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	_s := append([]interface{}{arg0}, arg1...)
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Errorf", _s...)
}

func (_m *MockLogger) Fatal(_param0 ...interface{}) {
	_s := []interface{}{}
	for _, _x := range _param0 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "Fatal", _s...)
}

func (_mr *_MockLoggerRecorder) Fatal(arg0 ...interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Fatal", arg0...)
}

func (_m *MockLogger) Fatalf(_param0 string, _param1 ...interface{}) {
	_s := []interface{}{_param0}
	for _, _x := range _param1 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "Fatalf", _s...)
}

func (_mr *_MockLoggerRecorder) Fatalf(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	_s := append([]interface{}{arg0}, arg1...)
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Fatalf", _s...)
}

func (_m *MockLogger) GetFields() xlog.F {
	ret := _m.ctrl.Call(_m, "GetFields")
	ret0, _ := ret[0].(xlog.F)
	return ret0
}

func (_mr *_MockLoggerRecorder) GetFields() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "GetFields")
}

func (_m *MockLogger) Info(_param0 ...interface{}) {
	_s := []interface{}{}
	for _, _x := range _param0 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "Info", _s...)
}

func (_mr *_MockLoggerRecorder) Info(arg0 ...interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Info", arg0...)
}

func (_m *MockLogger) Infof(_param0 string, _param1 ...interface{}) {
	_s := []interface{}{_param0}
	for _, _x := range _param1 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "Infof", _s...)
}

func (_mr *_MockLoggerRecorder) Infof(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	_s := append([]interface{}{arg0}, arg1...)
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Infof", _s...)
}

func (_m *MockLogger) Output(_param0 int, _param1 string) error {
	ret := _m.ctrl.Call(_m, "Output", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockLoggerRecorder) Output(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Output", arg0, arg1)
}

func (_m *MockLogger) OutputF(_param0 xlog.Level, _param1 int, _param2 string, _param3 map[string]interface{}) {
	_m.ctrl.Call(_m, "OutputF", _param0, _param1, _param2, _param3)
}

func (_mr *_MockLoggerRecorder) OutputF(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "OutputF", arg0, arg1, arg2, arg3)
}

func (_m *MockLogger) SetField(_param0 string, _param1 interface{}) {
	_m.ctrl.Call(_m, "SetField", _param0, _param1)
}

func (_mr *_MockLoggerRecorder) SetField(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "SetField", arg0, arg1)
}

func (_m *MockLogger) Warn(_param0 ...interface{}) {
	_s := []interface{}{}
	for _, _x := range _param0 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "Warn", _s...)
}

func (_mr *_MockLoggerRecorder) Warn(arg0 ...interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Warn", arg0...)
}

func (_m *MockLogger) Warnf(_param0 string, _param1 ...interface{}) {
	_s := []interface{}{_param0}
	for _, _x := range _param1 {
		_s = append(_s, _x)
	}
	_m.ctrl.Call(_m, "Warnf", _s...)
}

func (_mr *_MockLoggerRecorder) Warnf(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	_s := append([]interface{}{arg0}, arg1...)
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Warnf", _s...)
}

func (_m *MockLogger) Write(_param0 []byte) (int, error) {
	ret := _m.ctrl.Call(_m, "Write", _param0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockLoggerRecorder) Write(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Write", arg0)
}

// Mock of Output interface
type MockOutput struct {
	ctrl     *gomock.Controller
	recorder *_MockOutputRecorder
}

// Recorder for MockOutput (not exported)
type _MockOutputRecorder struct {
	mock *MockOutput
}

func NewMockOutput(ctrl *gomock.Controller) *MockOutput {
	mock := &MockOutput{ctrl: ctrl}
	mock.recorder = &_MockOutputRecorder{mock}
	return mock
}

func (_m *MockOutput) EXPECT() *_MockOutputRecorder {
	return _m.recorder
}

func (_m *MockOutput) Write(_param0 map[string]interface{}) error {
	ret := _m.ctrl.Call(_m, "Write", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockOutputRecorder) Write(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Write", arg0)
}
